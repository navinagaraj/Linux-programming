/**********************************************/
/* Author       : Naveenkumar N               */
/* Date         : 22-05-2020                  */
/* Filename     : readme                      */
/* Description  : About mprotect              */
/**********************************************/


The mprotect() system call changes the protection on the virtual memory pages in the range starting at addr and continuing for length bytes.The value given in addr must be a multiple of the system page size (as returned by sysconf(_SC_PAGESIZE)). (SUSv3 specified that addr must be page-aligned. SUSv4 says that an implementation may require this argument to be page-aligned.)Because protections are set on whole pages, length is, in effect, rounded up to the next multiple of the system page size. The prot argument is a bit mask specifying the new protection for this region of memory. It must be specified as either PROT_NONE or a combination created by ORing together one or more of PROT_READ , PROT_WRITE , and PROT_EXEC . All of these val-ues have the same meaning as for mmap() (Table 49-2, on page 1020).If a process attempts to access a region of memory in a manner that violates the memory protection, the kernel generates a SIGSEGV signal for the process.One use of mprotect() is to change the protection of a region of mapped memory originally set in a call to mmap(), as shown in Listing 50-1. This program creates an anonymous mapping that initially has all access denied ( PROT_NONE ). The program then changes the protection on the region to read plus write. Before and after mak-ing the change, the program uses the system() function to execute a shell command that displays the line from the /proc/ PID /maps file corresponding to the mapped  region, so that we can see the change in memory protection. (We could have obtained the mapping information by directly parsing /proc/self/maps , but we used the call to system() because it results in a shorter program.)
